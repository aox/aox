/* adler32.c -- compute the Adler-32 checksum of a data stream
 * Copyright (C) 1995-2002 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/* @(#) $Id$ */

#if defined( __MVS__ )
  /* MVS control section (CSECT) names default to the file name and cannot
	 match any extern function name in the file.  This only applies to the
	 CSECT compiler option.  Without a csect name, when maintenance is 
	 applied to an MVS program the newly introduced csect is ordered ahead 
	 of the previos csects.  With csect names, the new csect replaces the 
	 old csect.  So without csect names, as maintenance is applied 
	 throughout the life of the executable, the executable size 
	 continually increases--not a good thing.
	 
	 These files required the pragma since they contained external function
	 names that matched the file names, which is the default csect name
	 generated by the compiler with the csect option.  You cannot have the 
	 same externally visible name defined for two different entities */
  #pragma csect( CODE, "adler32C" )
  #pragma csect( STATIC, "adler32S" )
  #pragma csect( TEST, "adler32T" )
#endif /* __MVS__ */

#if defined( INC_ALL ) || defined( INC_CHILD )
  #include "zlib.h"
#else
  #include "zlib/zlib.h"
#endif /* Compiler-specific includes */

#define BASE 65521L /* largest prime smaller than 65536 */
#define NMAX 5552
/* NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1 */

#define DO1(buf,i)  {s1 += buf[i]; s2 += s1;}
#define DO2(buf,i)  DO1(buf,i); DO1(buf,i+1);
#define DO4(buf,i)  DO2(buf,i); DO2(buf,i+2);
#define DO8(buf,i)  DO4(buf,i); DO4(buf,i+4);
#define DO16(buf)   DO8(buf,0); DO8(buf,8);

/* ========================================================================= */
uLong ZEXPORT adler32(adler, buf, len)
    uLong adler;
    const Bytef *buf;
    uInt len;
{
    unsigned long s1 = adler & 0xffff;
    unsigned long s2 = (adler >> 16) & 0xffff;
    int k;

    if (buf == Z_NULL) return 1L;

    while (len > 0) {
        k = len < NMAX ? len : NMAX;
        len -= k;
        while (k >= 16) {
            DO16(buf);
	    buf += 16;
            k -= 16;
        }
        if (k != 0) do {
            s1 += *buf++;
	    s2 += s1;
        } while (--k);
        s1 %= BASE;
        s2 %= BASE;
    }
    return (s2 << 16) | s1;
}
